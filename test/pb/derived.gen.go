// Code generated by goderive DO NOT EDIT.

package pb

// deriveDeepCopy recursively copies the contents of src into dst.
func deriveDeepCopy(dst, src *Resource) {
	dst.Id = src.Id
	dst.Href = src.Href
	if src.ResourceTypes == nil {
		dst.ResourceTypes = nil
	} else {
		if dst.ResourceTypes != nil {
			if len(src.ResourceTypes) > len(dst.ResourceTypes) {
				if cap(dst.ResourceTypes) >= len(src.ResourceTypes) {
					dst.ResourceTypes = (dst.ResourceTypes)[:len(src.ResourceTypes)]
				} else {
					dst.ResourceTypes = make([]string, len(src.ResourceTypes))
				}
			} else if len(src.ResourceTypes) < len(dst.ResourceTypes) {
				dst.ResourceTypes = (dst.ResourceTypes)[:len(src.ResourceTypes)]
			}
		} else {
			dst.ResourceTypes = make([]string, len(src.ResourceTypes))
		}
		copy(dst.ResourceTypes, src.ResourceTypes)
	}
	if src.Interfaces == nil {
		dst.Interfaces = nil
	} else {
		if dst.Interfaces != nil {
			if len(src.Interfaces) > len(dst.Interfaces) {
				if cap(dst.Interfaces) >= len(src.Interfaces) {
					dst.Interfaces = (dst.Interfaces)[:len(src.Interfaces)]
				} else {
					dst.Interfaces = make([]string, len(src.Interfaces))
				}
			} else if len(src.Interfaces) < len(dst.Interfaces) {
				dst.Interfaces = (dst.Interfaces)[:len(src.Interfaces)]
			}
		} else {
			dst.Interfaces = make([]string, len(src.Interfaces))
		}
		copy(dst.Interfaces, src.Interfaces)
	}
	dst.DeviceId = src.DeviceId
	dst.InstanceId = src.InstanceId
	dst.Anchor = src.Anchor
	if src.Policies == nil {
		dst.Policies = nil
	} else {
		dst.Policies = new(Policies)
		*dst.Policies = *src.Policies
	}
	dst.Title = src.Title
	if src.SupportedContentTypes == nil {
		dst.SupportedContentTypes = nil
	} else {
		if dst.SupportedContentTypes != nil {
			if len(src.SupportedContentTypes) > len(dst.SupportedContentTypes) {
				if cap(dst.SupportedContentTypes) >= len(src.SupportedContentTypes) {
					dst.SupportedContentTypes = (dst.SupportedContentTypes)[:len(src.SupportedContentTypes)]
				} else {
					dst.SupportedContentTypes = make([]string, len(src.SupportedContentTypes))
				}
			} else if len(src.SupportedContentTypes) < len(dst.SupportedContentTypes) {
				dst.SupportedContentTypes = (dst.SupportedContentTypes)[:len(src.SupportedContentTypes)]
			}
		} else {
			dst.SupportedContentTypes = make([]string, len(src.SupportedContentTypes))
		}
		copy(dst.SupportedContentTypes, src.SupportedContentTypes)
	}
	if src.EndpointInformations == nil {
		dst.EndpointInformations = nil
	} else {
		if dst.EndpointInformations != nil {
			if len(src.EndpointInformations) > len(dst.EndpointInformations) {
				if cap(dst.EndpointInformations) >= len(src.EndpointInformations) {
					dst.EndpointInformations = (dst.EndpointInformations)[:len(src.EndpointInformations)]
				} else {
					dst.EndpointInformations = make([]*EndpointInformation, len(src.EndpointInformations))
				}
			} else if len(src.EndpointInformations) < len(dst.EndpointInformations) {
				dst.EndpointInformations = (dst.EndpointInformations)[:len(src.EndpointInformations)]
			}
		} else {
			dst.EndpointInformations = make([]*EndpointInformation, len(src.EndpointInformations))
		}
		deriveDeepCopy_(dst.EndpointInformations, src.EndpointInformations)
	}
}

// deriveDeepCopy_ recursively copies the contents of src into dst.
func deriveDeepCopy_(dst, src []*EndpointInformation) {
	for src_i, src_value := range src {
		if src_value == nil {
			dst[src_i] = nil
		} else {
			dst[src_i] = new(EndpointInformation)
			*dst[src_i] = *src_value
		}
	}
}
